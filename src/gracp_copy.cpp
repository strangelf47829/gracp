#include <gracp.h>
#include <fstream>

gracp::gracp(std::string in, std::string out)
{
	setInput(in);
	setOutput(out);

	std::string headerFile = out;
	char *hdFileName = headerFile.substr(0,headerFile.find("_c.cpp")).append("_c.h").data();
	head.open(hdFileName);
	hdFileName = headerFile.substr(0,headerFile.find(".cpp")).data();
	head << "#ifndef _GRACP_" << hdFileName << std::endl;
	head << "#define _GRACP_" << hdFileName << std::endl;
	//registerClass("counter");

	readFile();
	/*
	head << "//GRACP: Auto generated class definition. There are probably some issues with this definition, so just read whatever g++/gcc says. I aint fixin sheet" << std::endl;
	head << "class counter" << std::endl; //TODO: implement this later
	head << "{\n\tpublic:" << std::endl;
	for(int i = 0; i < ppc-1; i++)
	{	//		  Return                  Name           args
	       	head << "\t\t" << pp[i++].data() << pp[i++].data() << pp[i].data() << ";" << std::endl;
	}
	head << "};";*/


	//emitFunction("void", "counter", "add",false);
	//emitFunction("void", "counter", "sub",false);
	//emitFunction("int", "counter", "get", true);
}

void gracp::readFile()
{
	std::string line;
	std::string sec;
	bool comment = false;
	char currClass[128];

	while(std::getline(input,line))
	{
		if(line.rfind("//") != std::string::npos)
			continue;
		if(line.rfind("*/") != std::string::npos)
			comment = false;
		if(line.rfind("/*") != std::string::npos)
			comment = true;
		if(comment)
			continue;

		
		size_t _cl = line.find("class");
		if(_cl == 0)
		{
			char *className = line.data() + line.find(" ") + 1;
			if(className[line.length()-2-line.find(" ")] == ';')
					className[line.length()-2-line.find(" ")] = '\0';

			for(int i = 0; className[i]; i++)
				currClass[i] = className[i];

			registerClass(currClass);
		}


		size_t _fn = line.find(std::string(currClass).append("::"));
		size_t _fnc = line.find(";");
		if(_fn != std::string::npos && _fnc == std::string::npos)
		{
			//printf("new function definition found! %s", line.data());

			char return_name[(int)_fn];
			for(int i = 0; i < (int)_fn; i++)
				return_name[i] = *(line.data() + i);
			//"the type must come before the class name, so use that as the type variable
			
			
			//"Now the name of the function must come before the first parenthesese, and after the class name"
			int colonIndex = 0;
			int parenthIndex = 0;
			for(int i = (int)_fn; i < line.length(); i++)
			{
				if(line.data()[i] == ':')
					colonIndex = i;
				else if(line.data()[i] == '(')
				{
					parenthIndex = i;
					break;
				}
			}
			std::string _fncDec(line.data() + colonIndex + 1);
			std::string _fncName = _fncDec.substr(0,parenthIndex - colonIndex - 1);
			std::string _fncArgs = _fncDec.substr(_fncName.length()+1);
			_fncArgs = _fncArgs.substr(0,_fncArgs.length()-1);

			if(!_fncName.compare(std::string(currClass)))
				printf("constructor found!\n");
			else if(_fncName.data()[0] == '~')
				printf("destructor found!\n");
			else if(!_fncName.compare(std::string("_new")))
				printf("emitted constructor...\n");
			else if(!_fncName.compare(std::string("del")))
				printf("emitted destructor...\n");
			else
			{
				if(!_fncArgs.length())
					emitFunction(return_name, currClass, _fncName.data(),std::string(return_name).find("void") != 0);
				else
					emitFunction(return_name, currClass, _fncName.data(),_fncArgs.data(),std::string(return_name).find("void") != 0);
			}




		}

		
		
	}

}



void gracp::setInput(std::string iinput)
{
	//std::string shellCommand("cp ");
	//shellCommand = shellCommand.append(iinput).append(" ").append(iinput).append(".old");
	//system(shellCommand.data());
	//input.open(iinput.append(".old").data());
	input.open(iinput.data());
}

void gracp::setOutput(std::string ooutput)
{
	output.open(ooutput.data());
	output << "/* Autogenerated GRACP file.\n * Auth: Rafael de Bie\n */\n\n" << std::endl;
}

gracp::~gracp()
{
	printf("echo gracp done\n");
	input.close();
	output.close();
	head << "#endif" << std::endl;
	head.close();
	printf("gracp version %s\n", _GRACP_VER);
}

void gracp::registerClass(const char *_class)
{

	system(std::string("echo -=- Registering class ").append(_class).append(". Buffer len = ").append(_GRACP_BUFFSIZE(_class)).data());
	output << "\n//Auto generated arr. Default size can be adjusted in the gracp.h file." << std::endl;
	output << "//TODO: This definition is incomplete. g++ *will* complain about this. Please include the file that " << _class << " is defined in!" << std::endl;
	output << "class " << _class << ";" << std::endl;
	output << _class << " " << _class << "_inst[" << _GRACP_BUFFSIZE(_class) << "];\n" << std::endl;
	output << "//Auto generated constructor destructor funcs" << std::endl;
	output << "extern \"C\" void new_" << _class << "(unsigned int inst)\n{\n\t" << _class << "_inst[inst]._new();\n}\n" << std::endl;
	output << "extern \"C\" void delete_" << _class << "(unsigned int inst)\n{\n\t" << _class << "_inst[inst].del();\n}\n" << std::endl;

	head << "extern void new_" << _class << "(unsigned int inst); //Call this for constructor\n" << std::endl;
	head << "extern void delete_" << _class << "(unsigned int inst); //Call this for destructor\n" << std::endl;
}

void gracp::emitFunction(const char *_ret, const char *_class, const char *_name, bool _returns)
{
	head << "//Auto generated function in external file" << std::endl;
	head << "extern " << _ret << _class << "_" << _name << "(unsigned int inst);\n" << std::endl;
	printf(" -====- %s: Registering function %s. (no arguments, %s)\n",_class,_name,_returns?"returns value":"does not return value");
	
	output << "\n//Auto generated Function (No parameters found for " << _name << ")" << std::endl;
	output << "extern \"C\" " << _ret << _class << "_" << _name << "(unsigned int inst)\n{\n\t";
	output << (_returns ? "return " : "") << _class << "_inst[inst]." << _name << "();\n}\n" << std::endl;

	pp[ppc++] = std::string(_ret);
	pp[ppc++] = std::string(_name);
	pp[ppc++] = std::string("()");
}

void gracp::emitFunction(const char *_ret, const char *_class, const char *_name, const char *_args, bool _returns)
{
	head << "//Auto generated function in external file" << std::endl;
	head << "extern " << _ret <<  _class << "_" << _name << "(unsigned int inst, " << _args << ");\n" << std::endl;
	printf(" -====- %s: Registering functino %s. (Argumented, %s)\n",_class,_name,_returns?"returns value":"does not return value");

	output << "//Auto Generated Function" << std::endl;
	output << "extern \"C\" " << _ret << _class << "_" << _name << "(unsigned int inst, " << _args << ")\n{" << std::endl;
	output << (_returns ? "\treturn " : "\t") << _class << "_inst[inst]." << _name << "(" << _args << ");\n}" << std::endl;

	pp[ppc++] = std::string(_ret);
	pp[ppc++] = std::string(_name);
	pp[ppc++] = std::string("(").append(_args).append(")");	
}



